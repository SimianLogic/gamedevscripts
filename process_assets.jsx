//EXPORT OPTIONS (make a text layer called "options" with key:value pairs on each line)var export_full_size = true;var export_half_size = true;var full_size_postfix = "@2x";var half_size_postfix = "";var coordinates = "half";//half or fullvar origin = "top_left";var anchor = "top_left";var delimeter = "|";var item_delimeter = "||";var integers = true;var size_to_layer = true;//container is either app.activeDocument at the start//or a group (i.e. app.activeDocument.layerSets[0])function processAll(container){	var artLayers = container.artLayers.length;	for(var i = artLayers-1; i >= 0; i--)  //go in inverse depth order	{		processLayer(container.artLayers[i]);	}		var groups = container.layerSets.length;	for(var i = groups - 1; i >= 0; i--)	{		processAll(container.layerSets[i]);	}}var options = {};function getOptions(){	options = {};		var container = app.activeDocument;	var options_layer = null;	var artLayers = container.artLayers.length;	for(var i = artLayers-1; i >= 0; i--)  //go in inverse depth order	{		if(container.artLayers[i].name == "options")		{			options_layer = container.artLayers[i];			}	}	if(options_layer == null)	{		//using the defaults		return true;	}		if(options_layer.kind != LayerKind.TEXT)	{		alert("options must be a text layer!");		return false;	}		var raw_options_string = options_layer.textItem.contents;	var raw_options = raw_options_string.split('\r');		var op_length = raw_options.length;	for(var i=0; i < op_length; i++)	{		var key_val = raw_options[i].split(":");		switch(key_val[0])		{			case "export_full_size":				export_full_size = (key_val[1] == "true");				break;			case "export_half_size":				export_half_size = (key_val[1] == "true");				break;			case "full_size_postfix":				full_size_postfix = key_val[1];				break;			case "half_size_postfix":				half_size_postfix = key_val[1];				break;			case "origin":				origin = key_val[1];				break;			case "anchor":				anchor = key_val[1];				break;			case "delimeter":				delimeter = key_val[1];				break;			case "item_delimeter":				item_delimeter = key_val[1];				break;            case "coordinates":				coordinates = key_val[1];				break;                			case "integers":				integers = (key_val[1] == "true");				break;			case "size_to_layer":				size_to_layer = (key_val[1] == "true");				break;			default:				alert("INVALID OPTION " + key_val[0]);				return false;		}	}			return true;}//comment this out to turn off logging!function trace(string){    //$.writeln (string);}function processLayer(layer){    var layerName = layer.name;	var docRef = app.activeDocument;    var revert_state = docRef.activeHistoryState;        	if(layerName.indexOf("guide") == 0) return;	if(layerName == "options") return;		var x = parseInt((layer.bounds[0] + "").split(" ")[0]); //xyz px as a string => xyz	var y = parseInt((layer.bounds[1] + "").split(" ")[0]); //xyz px	var w = parseInt(((layer.bounds[2] - layer.bounds[0]) + "").split(" ")[0]); //xyz px	var h = parseInt(((layer.bounds[3] - layer.bounds[1]) + "").split(" ")[0]); //xyz px	var n = layer.name.split(" ").join("_");        var WIDTH  = parseInt((docRef.width  + "").split(" ")[0]); //xyz px    var HEIGHT = parseInt((docRef.height + "").split(" ")[0]); //xyz px		var output_x = x;	var output_y = y;        trace("========= " + n + " =================");    trace("SCREEN: " + WIDTH + "," + HEIGHT);    trace("pos: " + x + "," + y);    trace("w/h: " + w + "," + h);    	//we assume that the origin is top_left (y-neg) and the origin is the top left	//the other options swap these on their head	if(origin == "bottom_left")   //i.e. Unity, cocos2d	{		if(anchor == "top_left")		{			output_y = HEIGHT - y;		}else if(anchor == "bottom_left"){			output_y = HEIGHT - y - h;		}else if(anchor == "center"){			output_x = x + w/2;			output_y = HEIGHT - y - h/2;		}else{			alert("INVALID ANCHOR: " + anchor);		}			}else if(origin == "top_left"){		if(anchor == "top_left")		{			//nothing to see here!		}else if(anchor == "bottom_left"){			output_y = h + y;		}else if(anchor == "center"){			output_x = x + w/2;			output_y = y + w/2;		}else{			alert("INVALID ANCHOR: " + anchor);		}	}else if(origin == "center"){        		if(anchor == "top_left")		{			output_x = x - WIDTH/2;			output_y = HEIGHT/2 - y;		}else if(anchor == "center"){            var center_x = x + w/2;            trace("CENTER X = " + center_x);            trace("-" + WIDTH/2 + " = " + (center_x - WIDTH/2));            output_x = x + w/2 - WIDTH/2;                        var center_y = y + h/2;            trace("CENTER Y = " + center_y);            var inv_y = HEIGHT - center_y;            trace("INVERSE Y = " + inv_y);            trace("-" + (HEIGHT/2) + " = " + (inv_y - HEIGHT/2));            output_y = HEIGHT - (y + h/2) - HEIGHT/2;            		}else if(anchor == "bottom_left"){			output_x = x - WIDTH/2;			output_y = HEIGHT/2 - y - h;		}else{			alert("INVALID ANCHOR: " + anchor);		}			}else{		alert("INVALID ORIGIN: " + origin);	}    if(coordinates == "half")    {        trace("COORDINATES: HALF");        output_x = output_x / 2;        output_y = output_y / 2;    }    trace("OUT: " + output_x + "," + output_y);		if(layer.kind == LayerKind.TEXT && layer.name.indexOf("text") == 0)	{			var text_color = layer.textItem.color.rgb.hexValue;		var text_font = layer.textItem.font;		var text_just = (layer.textItem.justification + "").split(".")[1].toLowerCase();		var text_size = (layer.textItem.size/2 + "").split(" ")[0];				if(integers)		{					metadata.push(n + delimeter + Math.round(output_x) + delimeter + Math.round(output_y) + delimeter + text_color + delimeter + text_font + delimeter + text_just + delimeter + Math.round(text_size) + delimeter + Math.round(w) + delimeter + Math.round(h));		}else{			metadata.push(n + delimeter + output_x + delimeter + output_y + delimeter + text_color + delimeter + text_font + delimeter + text_just + delimeter + text_size + delimeter + w + delimeter + h);		}				return;	}	layer.visible = true;		if(integers)	{		metadata.push(n + delimeter + Math.round(output_x) + delimeter + Math.round(output_y));	}else{		metadata.push(n + delimeter + output_x + delimeter + output_y);	}			if(size_to_layer)	{		docRef.trim(TrimType.TRANSPARENT, true, true, true, true);	}	var safe_name = layerName.split(" ").join("_");	if(export_full_size) saveImage(safe_name + full_size_postfix);	if(export_half_size)	{		app.preferences.rulerUnits = Units.PERCENT;		app.activeDocument.resizeImage( 50,50 );		saveImage(safe_name + half_size_postfix);		app.preferences.rulerUnits = Units.PIXELS;	}	    docRef.activeHistoryState = revert_state;    layer.visible = false;    }function getTextSize(){	var ref = new ActionReference();	ref.putEnumerated( charIDToTypeID("Lyr "), charIDToTypeID("Ordn"), charIDToTypeID("Trgt") ); 	var desc = executeActionGet(ref).getObjectValue(stringIDToTypeID('textKey'));	var textSize =  desc.getList(stringIDToTypeID('textStyleRange')).getObjectValue(0).getObjectValue(stringIDToTypeID('textStyle')).getDouble (stringIDToTypeID('size'));	if (desc.hasKey(stringIDToTypeID('transform'))) {    	var mFactor = desc.getObjectValue(stringIDToTypeID('transform')).getUnitDoubleValue (stringIDToTypeID("yy") );    	textSize = (textSize* mFactor).toFixed(2);    }	return textSize;}function saveImage(layerName){	var Name = app.activeDocument.name.replace(/\.[^\.]+$/, ''); 	var Ext = decodeURI(app.activeDocument.name).replace(/^.*\./,''); 	if(Ext.toLowerCase() != 'psd') return; 	var Path = app.activeDocument.path; 	var short_name = app.activeDocument.name.split(".")[0];	var saveFile = File(Path + "/" + short_name + "/" + layerName); 	if(saveFile.exists) saveFile.remove(); 	SavePNG(saveFile); }function SavePNG(saveFile){     pngSaveOptions = new PNGSaveOptions(); 	activeDocument.saveAs(saveFile, pngSaveOptions, true, Extension.LOWERCASE); }function setAllVisible(container, visibility){	var artLayers = container.artLayers.length;	for(var i = 0; i < artLayers; i++)	{		container.artLayers[i].visible = visibility;	}		var groups = container.layerSets.length;	for(var i = groups - 1; i >= 0; i--)	{		setAllVisible(container.layerSets[i], visibility);	}	}function setupExportDirectory(){	var short_name = app.activeDocument.name.split(".")[0];	var path = app.activeDocument.path;		var export_folder = new Folder(path + "/" + short_name);		if(export_folder.exists)	{		folderDelete(path + "/" + short_name);	}	   	export_folder.create();}function folderDelete(topLevel){		var folder = Folder(topLevel);	var files = folder.getFiles();	for(var f in files)	{		files[f].remove();	}		folder.remove();}var metadata;function writeMetadata(){	var path = app.activeDocument.path; 	var short_name = app.activeDocument.name.split(".")[0];	var out = new File(path + "/" + short_name + "/metadata.txt");	out.open('w');	for(var i=0; i < metadata.length; i++)	{		out.write(metadata[i]);		if(i < metadata.length - 1)		{			out.write(item_delimeter);		}	}	out.close();	}function main(){    var initial_units = app.preferences.rulerUnits;	app.preferences.rulerUnits = Units.PIXELS;	//bomb out if our options are malformed	if(!getOptions())	{		return;	}	var docRef = app.activeDocument	    var initial_state = docRef.activeHistoryState;        	var start_history = docRef.historyStates.length - 1;	docRef.crop(new Array(0,0,docRef.width, docRef.height));	metadata = [];	setupExportDirectory();	setAllVisible(app.activeDocument, false);		processAll(app.activeDocument);		writeMetadata();	setAllVisible(app.activeDocument, true);				docRef.activeHistoryState = initial_state;    app.preferences.rulerUnits = initial_units;	alert("Process complete");}main();